# Инфраструктура: требования к интеграции

Правила работы с PostgreSQL/Redis/Kubernetes/repository providers/секретами/внешними API.
Инфраструктура — деталь и должна быть инкапсулирована (domain/service слои не знают про конкретные SDK).

## PostgreSQL: обязательная модель хранения

- PostgreSQL — единый backend состояния платформы.
- Используем:
  - реляционные таблицы для сущностей и связей;
  - `JSONB` для сессионных/событийных payload;
  - `pgvector` для векторного индекса документов/чанков.
- Схема меняется только миграциями (goose; `-- +goose Up/Down`).
  - В монорепо миграции живут *внутри держателя схемы*:
    `services/<zone>/<service>/cmd/cli/migrations/*.sql`.
  - Если БД/схема общая для нескольких сервисов, всё равно должен быть *один владелец*,
    а остальные сервисы обращаются к БД через его API/контракты (shared DB без владельца запрещён).
- SQL только в `internal/repository/postgres/<model>/sql/*.sql` + `//go:embed`.
- Каждый SQL-запрос в repo слое должен иметь имя-комментарий
  `-- name: <model>__<operation> :one|:many|:exec`.
- Repo слой возвращает доменно-осмысленные ошибки; домен не знает про SQL/pgx.

## Redis (опционально)

- Только для кэша/эфемерных данных/локов.
- Redis не source of truth.
- TTL обязателен по умолчанию.

## Kubernetes интеграция

- Только Kubernetes как оркестратор.
- Все операции выполняются через Go SDK (`client-go`) и адаптеры.
- Shell-вызовы `kubectl` допустимы только как аварийный fallback и не должны быть основной реализацией.
- Действия, меняющие состояние (pods/deployments/namespaces/secrets), логируются в аудит.
- Для multi-pod корректности используется блокировка/синхронизация через БД.

## Webhook/event processing

- Вход в систему — webhook события от repository providers.
- Каждое событие получает correlation id, сохраняется в БД и обрабатывается идемпотентно.
- Повторная доставка webhook не должна приводить к дублированию действий.
- Долгие операции выполняются через job worker с retry/backoff и фиксированием статуса.

## Repository providers (GitHub/GitLab)

- Интеграция только через provider-интерфейсы.
- GitHub — первая реализация; GitLab добавляется без изменения доменного слоя.
- Token lifecycle (создание/ротация/ревокация) реализуется в сервисе.
- Токены в БД храним в зашифрованном виде.

## Секреты и конфигурация

- Секреты платформы и конфиг деплоя `codex-k8s` читаются из env.
- Пользовательские настройки продукта хранятся в БД и управляются через UI.
- Секреты не коммитим, не логируем и не возвращаем в API-ответах.
- В логах и audit payload запрещены ключи и токены в открытом виде.

## CI/CD, образы и окружения

- Каждый Go сервис имеет Dockerfile и воспроизводимую сборку.
- `services.yaml` — единый инвентарь deploy-конфигурации в рамках репозитория.
- `services.yaml/spec.versions` задаётся только объектным форматом:
  - `service: { value: "0.1.0", bumpOn: ["services/<zone>/<service>", ...] }`.
- Для build image `tagTemplate` должен ссылаться на `spec.versions` через рендер-контекст (`{{ index .Versions "<service>" }}`), а не дублировать версию литералом.
- Для `push` в `main/master` допускается авто-bump версии по `bumpOn`:
  - если в merge-коммитах есть изменённый путь, совпадающий с `bumpOn`, платформа поднимает последний numeric token версии;
  - bump коммитится в `main/master`, после чего deploy идёт по новому тегу.
- Платформа должна уметь развернуться в готовый кластер или установить `k3s` через `bootstrap`.
