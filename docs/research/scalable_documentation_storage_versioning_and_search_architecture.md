# Масштабируемая архитектура хранения, версионирования и поиска документации

## Структура хранения документации: Git и PostgreSQL

### Git: репозиторий DocSet

Основным хранилищем проектной и продуктовой документации остается Git-репозиторий с Markdown-файлами. Документы организованы по структуре DocSet: каждому артефакту соответствует отдельный Markdown-файл с унифицированной фронт-матерой (метаданными) и содержанием документа.

Предусмотрена обязательная YAML-шапка с полями:
- `doc_id`
- `type` (вид документа, например PRD, ADR, Design)
- `status` (draft/approved/superseded/obsolete)
- `owner_role` (ответственная роль)
- связи:
  - `related_issues`
  - `related_prs`
  - `supersedes` / `superseded_by` (для версионности)

Такая структура позволяет:
- идентифицировать документы по уникальному `doc_id`;
- хранить документы в Git с полной историей изменений.

Помимо самих документов, в репозитории хранится вспомогательная документация:
- файлы трассируемости (например, Issue Map: матрица соответствия Issue/PR ↔ документы ↔ релизы);
- DocSet-файлы, описывающие связь конкретного Issue или PR с набором документов (например `docs/_docset/issues/issue-123.yaml`).

Git обеспечивает:
- надежное версионирование (коммиты, ветки, PR);
- обзор изменений (diff, pull request review), критичный для командной работы над документацией.

### PostgreSQL и pgvector: индексация, поиск и интеграция с AI

Для эффективного поиска и интеграции с AI-агентами контент документов дублируется и индексируется в базе данных. Предпочтительный подход - единый PostgreSQL, расширенный модулем `pgvector` для хранения эмбеддингов.

В БД предусмотрены основные таблицы знаний:

1) `docs_meta`
- хранит метаданные и актуальное содержимое каждого документа:
  - `doc_id`
  - название и тип документа
  - статус
  - полный Markdown-текст (`body_markdown`)
  - прочая информация из фронт-маттеры в формате JSON
- при изменениях через Git (мерж PR) запись в `docs_meta` обновляется, поддерживая консистентность.

2) `doc_chunks`
- хранит фрагменты (чанки) документов для семантического поиска.
- документ разбивается на небольшие части (например, по параграфу или заголовку), для каждой части вычисляется embedding.
- сохраняется:
  - ссылка на документ (`doc_id`)
  - номер чанка
  - текст чанка
  - embedding
  - метаданные чанка (например заголовки, ссылки)
- на поле embedding создается векторный индекс (pgvector, например HNSW или ivfflat) для быстрого поиска похожих фрагментов.

3) `links`
- реализует явные связи M:N между сущностями Issue, PR, Run (запуск агента) и Doc (документ).
- позволяет отслеживать трассируемость: какие документы относятся к какому таску или релизу.
- при связывании документа с Issue через DocSet-агента создается запись в `links` (issue ↔ doc), дублирующая логику YAML docset-файлов.
- в результате можно строить матрицу трассируемости или выбирать все документы по конкретному Issue/PR.

### Сравнение ролей Git и PostgreSQL

| Хранилище | Роль и содержимое |
|---|---|
| Git (репозиторий) | Первичное хранилище Markdown-документов (DocSet). Обеспечивает версионирование, совместную работу через PR, видимость изменений (diff). Хранит структуру папок, фронт-маттер и ссылки (issue_map, docset файлы). |
| PostgreSQL + pgvector | Вторичное хранилище для индексации и поиска. Содержит текущую версию каждого документа и метаданные (`docs_meta`), а также чанки с эмбеддингами для быстрого семантического поиска (`doc_chunks`). Хранит связи для запросов трассируемости (`links`). Обеспечивает доступ для агентов и UI без прямого обращения к Git. |

Принцип синхронизации:
- репозиторий остается источником истины по содержанию;
- база - оперативный слой для чтения/поиска.

---

## Модель версионирования документов и чанков

### Версионирование на уровне Git

Каждый документ в Markdown хранится в Git, поэтому изменения проходят через коммиты и pull request-ы. История правок полностью сохраняется:
- можно просмотреть предыдущие версии;
- можно сравнить изменения (diff).

Практики:
- новые или правленные документы публикуются через ветку и PR;
- значимые документы требуют апрува (например, владельцем продукта), что поддерживает качество и актуальность.

Дополнительно в метаданных документа:
- `status` отражает этап (draft/approved/etc.);
- `supersedes` / `superseded_by` задают преемственность документов.

Пример логики:
- старый документ получает статус `superseded` и ссылку на новый документ;
- новый документ содержит ссылку на предыдущий, что позволяет прослеживать эволюцию артефакта.

### Версионирование на уровне БД

В `docs_meta` хранится только актуальная версия содержания (поле `body_markdown` обновляется при изменении документа). Поля вроде `created_at` и `updated_at` позволяют отслеживать время последней правки.

Явная история версий в БД не дублируется (чтобы не повторять функциональность Git). Доступ к старым версиям обеспечивается через Git (история коммитов, теги).

Статусы и связи (`superseded`, `superseded_by`) помогают понимать актуальность документа и в БД.

### Обновление чанков

Каждое изменение контента документа требует пересоздания связанных чанков для корректности поиска.

Предусмотрено автоматическое переиндексирование после мержа изменений (через MCP-инструменты). Примерный подход:
- пересчитать эмбеддинги документа;
- обновить записи в `doc_chunks`:
  - либо обновлять существующие чанки,
  - либо удалить все чанки по `doc_id` и записать новые.

Исторические версии чанков обычно не сохраняются:
- чтобы не раздувать индекс;
- чтобы не мешать поиску (по умолчанию поиск идет по актуальной документации).

Если нужен поиск по старым версиям:
- использовать конкретный коммит в Git;
- либо хранить отдельный архив.

### Гранулярность версионности

Так как "один документ = один Markdown-файл", версионирование происходит на уровне артефакта.

`doc_id` стабилен и не меняется от версии к версии, но возможны два подхода:
- обновление в рамках того же документа (единый `doc_id`, история в Git, статус меняется по мере утверждения);
- создание нового документа при коренном пересмотре (новый `doc_id`, старый помечается `superseded`, связи в `links` обновляются, старый остается как архивный).

В БД хранится:
- актуальный срез;
- метки статусов для понимания актуальности.

---

## Нужен ли дополнительный слой: DocStore поверх Git

### Проблема прямого использования Git

Хотя Git хорошо подходит для версии и хранения, прямое взаимодействие с ним из автоматизированной системы и агентных пайплайнов затруднено:
- нужно парсить репозиторий;
- выполнять коммиты;
- разрешать конфликты;
- UI-редактирование через PR не всегда удобно для нетехнических ролей.

Отсюда возникает вопрос о промежуточном слое "DocStore", который предоставляет более высокоуровневые API для чтения/записи документов и синхронизируется с Git.

### Подход через MCP

В данной системе роль такого слоя во многом выполняет MCP - шлюз оркестрации. Правило: DocSet-агент не пишет документы напрямую, а делает это через MCP с логированием и при необходимости апрувом.

Примеры MCP-инструментов:
- KB-инструменты для операций с БД:
  - `kb_doc_upsert_meta` (добавить/обновить запись в `docs_meta`)
  - `kb_doc_index_chunks` (пересчитать embeddings и записать чанки в `doc_chunks`)
  - `kb_link_issue_doc` (зафиксировать связь Issue-Doc)
- DocSet-инструменты для Git:
  - `docset_sync_issue`
  - `docset_sync_pr`
  - генерация/обновление YAML docset и матрицы трассируемости (`issue_map.md`)
  - создание коммита или PR с изменениями
- MCP сохраняет действия (audit trail) и может требовать апрув.

Итоговая позиция:
- MCP + Postgres реализуют слой DocStore, где Postgres хранит актуальное состояние, а Git используется как backend версионирования и внешнего взаимодействия.
- слой не дублирует Git, а дополняет его: хранит текущую версию и обеспечивает операции редактирования/поиска в реальном времени.

---

## Архитектура UI для редактирования и согласования документов

Планируется веб-интерфейс для ручного редактирования и утверждения документации, с поддержкой многопользовательской работы и встроенного ревью.

### Веб-редактор Markdown
- просмотр документа (рендеринг Markdown) и внесение изменений (WYSIWYG или текстовый редактор);
- при открытии редактора система загружает актуальное содержание документа из БД (`docs_meta`) по `doc_id`;
- редактор отображает метаданные (статус, автора/роль владельца);
- если документ `approved`, может быть read-only без специальных разрешений.

### Черновики и фиксация изменений

Варианты:
1) Через ветку Git
- UI создает ветку (или форк), сохраняет изменения коммитом.
- затем открывается PR на слияние в основную ветку.
- процесс можно скрыть от пользователя: кнопка "Предложить изменения" создает PR.

2) Через внутренний буфер в БД
- UI сохраняет изменения во временное хранилище (например в `docs_meta` как draft или отдельную сущность `document_draft`).
- можно показывать diff до/после.
- после "Отправить на апрув" система создает коммит/PR от имени пользователя или бота.

Рекомендация: интеграция с GitHub PR, чтобы переиспользовать привычный процесс комментариев и историю.

### Комментирование и рецензирование
- можно переиспользовать механизмы GitHub PR review (комментарии к строкам, обсуждения, запрос доработок);
- либо реализовать собственные комментарии в UI, но рациональнее использовать GitHub review.

### Апрув и слияние
Процесс апрува (например, кнопка "Утвердить" доступна роли Owner):
- либо GitHub API выставляет "Approved" и затем мерджит PR;
- либо при варианте без PR помечается документ как утвержденный и выполняется коммит в main через MCP/DocStore:
  - сохранить контент в `docs_meta`
  - пересобрать `doc_chunks`
  - зафиксировать изменения в Git

С точки зрения прозрачности истории предпочтительнее PR.

### Управление правами и конкуренцией
- все роли могут предлагать изменения, но мердж всегда за Owner;
- возможен RBAC по типам документов;
- конфликты одновременного редактирования решаются через Git (PR-конфликты) или через механизм lock (например поле `edit_locked_by` в `docs_meta`).

### Интеграция с агентами
- агенты могут генерировать документ и создавать PR;
- UI показывает автосгенерированные документы для доработки человеком;
- цикл: агент создает draft → человек правит → Owner утверждает.

---

## Безопасный доступ агентов к документам и обновление индексов

В агентной системе важно дать доступ к знаниям и возможность пополнения, сохранив контроль.

### Чтение документации
Агенты не читают Git напрямую. Вместо этого:
- используют поиск по документации через MCP (RAG):
  - например `kb_search_docs(query)` выполняет векторный поиск по `doc_chunks` в Postgres;
  - агент получает релевантные чанки с указанием источника (doc_id, заголовок).
- для полного текста:
  - например `kb_get_doc(doc_id)` читает `docs_meta.body_markdown`.

Все операции чтения только через контролируемый API, без прямых паролей и без доступа к структуре базы.

Опционально можно фильтровать выдачу:
- по проекту;
- по типу документа;
- по правам доступа.

### Инициирование изменений
Если агент считает нужным обновить/создать документ:
- он не коммитит напрямую;
- формирует запрос через MCP-инструмент, например `doc_update_request(doc_id, new_content, comment)`;
- MCP регистрирует запрос (например в `mcp_action_requests`), затем:
  - либо применяет автоматически (редко);
  - либо требует апрува: создается PR с лейблом `needs: review`, Owner получает уведомление (Telegram/GitHub), и только после явного approved изменения применяются (мерж PR или коммит).

При апруве MCP:
- обновляет `docs_meta`;
- пересобирает `doc_chunks`;
- обновляет `links`;
- логирует действия для аудита (например `flow_events`).

### Отслеживание изменений и аудит
- MCP логирует операции записи как события;
- `mcp_action_requests` хранит статусы requested/approved/applied и кто утвердил;
- Git-история коммитов обеспечивает дополнительный аудит.
- агентные коммиты могут делаться от имени технического пользователя (например "DocBot") с упоминанием инициатора в сообщении коммита.

### Обновление индексов
- обычно индекс обновляется автоматически при мерже изменений документа;
- для массового переиндексирования (например сменился алгоритм эмбеддингов) предусмотрен отдельный инструмент, например `kb_doc_reindex(doc_id or project_id)`, доступный администраторам или DocSet-агенту.

### Принцип наименьших прав
- агенты могут только то, что явно разрешено инструментами;
- Dev-агент может предложить обновление технических документов, но не может самовольно удалять документ или менять статус на `approved`;
- DocSet/KM агент может выполнять вспомогательные технические операции (разбиение на чанки, пересчет индексов), но тоже через MCP.

---

## Масштабирование и управление ростом базы знаний

### Шардинг по проектам или областям
Если платформа поддерживает множество проектов:
- добавить в `docs_meta` поле `project_id`;
- партиционировать `doc_chunks` по проектам;
- ограничивать векторный индекс по `project_id` условиями запроса.

Для одного очень большого проекта возможно логическое разбиение по подсистемам (подпапки docset/модули), но слишком мелкий шардинг усложняет поддержку.

### Архивирование устаревшей документации
Документы со статусами `obsolete` или `superseded`, а также документы по закрытым инициативам можно архивировать.

Варианты:
- Git: перемещать файлы в `archive/` или в отдельный бранч/репозиторий архива.
- БД: помечать статусом и исключать из поиска; удалять соответствующие `doc_chunks` или переносить в `doc_chunks_archive`.

Можно предоставить отдельный режим поиска по архиву "по запросу", а основной режим держать только по актуальным документам.

### Очистка старых версий
- в Git история остается;
- в БД нет смысла хранить множество ревизий: лучше хранить только актуальный срез.
Если появляются черновики, не нужные после утверждения, нужен механизм очистки (или изначально не копить ревизии в БД).

### Управление размером эмбеддингов
Эмбеддинги занимают значимый объем. При росте числа документов число строк в `doc_chunks` может быть очень большим.

Практики:
- настраивать параметры индекса ivfflat/HNSW под объем данных;
- периодически перестраивать индекс после массовых удалений (например после архивации);
- при экстремальном росте рассмотреть специализированные векторные хранилища (ElasticSearch vectors, Milvus, Weaviate), понимая, что это усложнит архитектуру.

### Мониторинг и лимиты
Ввести метрики:
- число документов;
- суммарный объем текста;
- количество чанков;
- размер индекса.

На основе метрик:
- если документ "разрастается", KM-агент предлагает разбить его на несколько;
- можно вводить политики архивации (например документы старше N лет переводить в архив, неактивные проекты архивировать спустя год после релиза).

### Поведение с superseded документами
Рекомендации:
- по умолчанию исключать `superseded` документы из поиска, чтобы не выдавать устаревшее;
- в UI явно помечать устаревшие документы и показывать ссылку на заменяющий через `superseded_by`;
- при навигации по связям (Issue → Doc) либо скрывать устаревшие, либо показывать их "серым" и с явной пометкой;
- физически удалять контент не рекомендуется, лучше держать в Git-архиве; из БД можно удалять после длительного неиспользования (например через год), если ссылки больше не нужны.

